// ---------------------------------------------------------------------------------------------------------------------
// Imports
// ---------------------------------------------------------------------------------------------------------------------
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace CodeOfChaos.CliArgsParser.Generators;

// ---------------------------------------------------------------------------------------------------------------------
// Code
// ---------------------------------------------------------------------------------------------------------------------
[Generator(LanguageNames.CSharp)]
public class CliArgsParameterGenerator : IIncrementalGenerator{

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        IncrementalValueProvider<ImmutableArray<CliArgsParameterStructDto>> parameterStructs = context.SyntaxProvider
            .CreateSyntaxProvider(
                IsParameterStruct,
                GatherParameterStruct
            ).Collect();
        
        context.RegisterSourceOutput(context.CompilationProvider.Combine(parameterStructs), GenerateSources);
    }

    private static bool IsParameterStruct(SyntaxNode node, CancellationToken _) {
        if (node is not StructDeclarationSyntax { BaseList: { Types.Count: > 0 } baseList, Members: var members }) return false;

        if (!baseList.Types.Any(
                type => type.Type is IdentifierNameSyntax genericNameSyntax
                    && genericNameSyntax.Identifier.ValueText.Contains("IParameters")
            )) return false;

        return members.OfType<PropertyDeclarationSyntax>()
            .SelectMany(prop => prop.AttributeLists.SelectMany(attrlist => attrlist.Attributes))
            .Any(attr => attr.Name.ToString().Contains("CliArgsParameter")
            );

    }

    private static CliArgsParameterStructDto GatherParameterStruct(GeneratorSyntaxContext context, CancellationToken cancellationToken) {
        var structSyntax = (StructDeclarationSyntax)context.Node;
        ISymbol structSymbol = ModelExtensions.GetDeclaredSymbol(context.SemanticModel, structSyntax)!;

        CliArgsParameterPropertyDto[] properties = structSyntax.Members
            .OfType<PropertyDeclarationSyntax>()
            .Where(prop => prop.AttributeLists.Any(attrlist => attrlist.Attributes.Any(attr => attr.Name.ToString().Contains("CliArgsParameter"))))
            .Select(syntax => CliArgsParameterPropertyDto.FromPropertyDeclarationSyntax(
                syntax,
                ModelExtensions.GetDeclaredSymbol(context.SemanticModel, syntax)!) // Try (or raise exception) to get symbol
            )
            .ToArray();

        return new CliArgsParameterStructDto {
            Symbol = structSymbol,
            IsNotPartial = !structSyntax.Modifiers.Any(modifier => modifier.IsKind(SyntaxKind.PartialKeyword)),
            ClassName = structSymbol.Name,
            Namespace = structSymbol.ContainingNamespace.ToDisplayString(),
            PropertyDtos = properties,
        };
    }
    
    private static void GenerateSources(SourceProductionContext context, (Compilation Left, ImmutableArray<CliArgsParameterStructDto> Right) source) {
        (_, ImmutableArray<CliArgsParameterStructDto> cliArgsParameterStructDtos) = source;
        StringBuilder builder = new();

        foreach (CliArgsParameterStructDto dto in cliArgsParameterStructDtos) {
            builder.AppendLine("// <auto-generated />")
                .AppendLine($"namespace {dto.Namespace};")
                .AppendLine("#nullable enable")
                .AppendLine($"public partial struct {dto.ClassName}() {{")
                .IndentLine(1, $"public {dto.ClassName} FromRegistry(CommandInputRegistry registry) {{")
                .IndentLine(2, $"return new() {{");

            foreach (CliArgsParameterPropertyDto propertyDto in dto.PropertyDtos) {
                if (propertyDto.IsRequiredProperty) {
                    builder.IndentLine(3, $"{propertyDto.PropertyName} = registry.GetParameter<{propertyDto.PropertyType}>(\"{propertyDto.Name}\"),");
                    continue;
                }
                
                builder.IndentLine(3, $"{propertyDto.PropertyName} = registry.GetOptionalParameter<{propertyDto.PropertyType}>(\"{propertyDto.Name}\") ?? {propertyDto.PropertyDefaultValue},");
                
            }
            
            builder.IndentLine(2, "};")
                .IndentLine(1, "}")
                .AppendLine("}");
            
            context.AddSource($"{dto.ClassName}.g.cs", builder.ToString());
            builder.Clear();
        }
        
        
    }
}
