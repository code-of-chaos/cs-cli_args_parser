// ---------------------------------------------------------------------------------------------------------------------
// Imports
// ---------------------------------------------------------------------------------------------------------------------
using CodeOfChaos.CliArgsParser.Generators.Helpers;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;

namespace CodeOfChaos.CliArgsParser.Generators;

// ---------------------------------------------------------------------------------------------------------------------
// Code
// ---------------------------------------------------------------------------------------------------------------------
[Generator(LanguageNames.CSharp)]
public class CliArgsParameterGenerator : IIncrementalGenerator{

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        IncrementalValueProvider<ImmutableArray<CliArgsParameterStructDto>> parameterStructs = context.SyntaxProvider
            .CreateSyntaxProvider(
                IsParameterStruct,
                GatherParameterStruct
            ).Collect();
        
        context.RegisterSourceOutput(context.CompilationProvider.Combine(parameterStructs), GenerateSources);
    }

    private static bool IsParameterStruct(SyntaxNode node, CancellationToken _) {
        if (node is not StructDeclarationSyntax { BaseList: { Types.Count: > 0 } baseList, Members: var members }) return false;

        if (!baseList.Types.Any(
                type => type.Type is IdentifierNameSyntax genericNameSyntax
                    && genericNameSyntax.Identifier.ValueText.Contains("IParameters")
            )) return false;

        return members.OfType<PropertyDeclarationSyntax>()
            .SelectMany(prop => prop.AttributeLists.SelectMany(attrs => attrs.Attributes))
            .Any(attr => attr.Name.ToString().Contains("CliArgsParameter")
            );

    }

    private static CliArgsParameterStructDto GatherParameterStruct(GeneratorSyntaxContext context, CancellationToken cancellationToken) {
        return CliArgsParameterStructDto.FromSyntax(context, (StructDeclarationSyntax)context.Node);
    }
    
    private static void GenerateSources(SourceProductionContext context, (Compilation Left, ImmutableArray<CliArgsParameterStructDto> Right) source) {
        (_, ImmutableArray<CliArgsParameterStructDto> cliArgsParameterStructDtos) = source;
        IndentedStringBuilder builder = new();

        foreach (CliArgsParameterStructDto dto in cliArgsParameterStructDtos) {
            if (!dto.IsPartial) {
                // Create and spawn a diagnostic error to explain that the struct has to be a partial
                context.ReportDiagnostic(Diagnostic.Create(new DiagnosticDescriptor(
                    "CLI001",
                    "Struct must be partial",
                    "The struct '{0}' must be declared as partial to support CLI argument parsing.",
                    "Usage",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                    dto.Symbol.Locations.First(),
                    dto.ClassName));
            }
            
            builder
                .AppendLine("// <auto-generated />")
                .AppendLine("using CodeOfChaos.CliArgsParser;")
                .AppendLine($"namespace {dto.Namespace};")
                .AppendLine("#nullable enable")
                .AppendLine($"public partial struct {dto.ToStructDeclarationName()} {{")
                .IndentLine($"public {dto.ClassName} FromRegistry(CommandInputRegistry registry) {{")
                .IndentLine($"return new() {{");

            foreach (CliArgsParameterPropertyDto propertyDto in dto.PropertyDtos) {
                if (!propertyDto.IsValid) {
                    // TODO spawn correct diagnostics
                }
                builder.AppendLine(propertyDto.ToPropertyInitialization());
            }

            builder
                .UnIndentLine("};")
                .UnIndentLine("}");
            
            context.AddSource($"{dto.ClassName}.g.cs", builder.ToString());
            builder.Clear();
        }
        
        
    }
}
